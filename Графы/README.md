# graph_1

## Матрица смежности неориентированного графа
В галактике "Milky Way" в системе звезды "Sirius" на планете "Neptune" есть N городов, некоторые из которых соединены дорогами. Император "Maximus" галактики "Milky Way" решил провести инвентаризацию дорог на планете "Neptune". Но, как оказалось, он не силен в математике, поэтому он просит вас сосчитать количество дорог.

## Входные данные
В первой строке задается число N (0 ≤ N ≤ 100). В следующих N строках содержится по N чисел, каждое из которых является единичкой или ноликом. Причем, если в позиции (i,j) квадратной матрицы стоит единичка, то i-ый и j-ый города соединены дорогами, а если нолик, то не соединены. Граф неориентированный, петель нет.

## Выходные данные
Выведите одно число - количество дорог на планете "Neptune".

## Примеры
Вход|Выход
---|---
5<br>0 1 0 0 0<br>1 0 1 1 0<br>0 1 0 0 0<br>0 1 0 0 0<br>0 0 0 0 0|3

## [Решение](graph_1.c)

---

# graph_2

## От матрицы смежности к списку ребер, неориентированный вариант
Простой неориентированный граф задан матрицей смежности, выведите его представление в виде списка ребер.

## Входные данные
В первой строке задается число N (0 ≤ N ≤ 100). В следующих N строках содержится по N чисел, каждое из которых является единичкой или ноликом - матрица смежности. Считаем, что города нумеруются с 0.

## Выходные данные
Выведите список ребер заданного графа в следующем порядке: вторая вершина ребра меньше первой, ребра идут по возрастанию номеров первых вершин, при равных первых - по возрастанию второй вершины.

## Примеры
Вход|Выход
---|---
3<br>0 1 1<br>1 0 1<br>1 1 0|1 0<br>2 0<br>2 1

## [Решение](graph_2.c)

---

# graph_3

## От списка ребер к матрице смежности, неориентированный вариант
Простой неориентированный граф задан списком ребер, выведите его представление в виде матрицы смежности.

## Входные данные
В первой строке задается число N (1 ≤ N ≤ 100) - количество вершин в графе, и M (1≤ M ≤ N(N - 1)/2) – количество ребер. Затем следует M пар чисел – ребра графа. Считаем, что вершины нумеруются с 0.

## Выходные данные
Матрица смежности из 0 и 1.

## Примеры
Вход|Выход
---|---
3 3<br>0 1<br>1 2<br>0 2|0 1 1<br>1 0 1<br>1 1 0

## [Решение](graph_3.c)

---

# graph_4

## Банкет
На допрос были доставлены N Очень Важных Коррупционера (ОВК). Были подготовлены 2 СИЗО. Они достаточно большие, чтобы все коррупционеры могли сесть в любой из них. Проблема заключается в том, что некоторые ОВК связаны друг с другом и не могут сидеть в одном СИЗО, так как могут договориться друг с другом и согласовать фальшивые показания. Агентство Социальной Безопасности попросило Вас определить, возможно ли всех ОВК рассадить в 2 СИЗО.

## Входные данные
В первой строке входных данных содержатся два числа: N и M (1 ≤ N,M ≤ 100), где N – количество ОВП, а M – количество пар ОВК, которые не могут сидеть в одном СИЗО. В следующих M строках записано по 2 числа – пары ОВК, которые не могут сидеть в одним СИЗО. Считаем, что персоны нумеруются с 0.

## Выходные данные
Если способ рассадить ОВК существует, то выведите YES в первой строке и номера ОВП, которых необходимо посадить в первый СИЗО, во второй строке. Персон выводить по возрастанию их номеров. Если персона может сесть в любой СИЗО, сажайте ее в первый.
В противном случае в первой и единственной строке выведите NO.

## Примеры
Вход|Выход
---|---
3 2<br>0 1<br>0 2|YES<br>0

## [Решение](graph_4.cpp)

---

# eulerian

## Поймать террориста Эйлера
Мосты города Малининграда заданы в виде неориентированного ~~связанного герцога~~ связного графа, который может содержать петли и кратные рёбра и задан своей симметричной матрицей смежности. В Агентство Социальной Безопасности поступила анонимка, что террорист Эйлер планирует обойти их все и заминировать. Он не хочет подорваться на своей мине, поэтому по каждому мосту собирается проходить ровно по одному разу. Директор Агентства Глеб Жеглов хочет узнать, осуществим ли такой план и верить ли анонимке.

Известно, что все вертолёты агрессивного Северо-Длиннопрудного Альянса были подбиты, так что сообщники не смогут забрасывать террориста Эйлера на один остров и забирать с другого, так что ему придётся вернуться в конспиративную квартиру

## Входные данные
На первой строке задаётся число N (1 ≤ N ≤ 100) – количество вершин в графе. Следом идёт сама матрица смежности графа в виде N строк, в каждой из которых по N неотрицательных чисел. Считаем, что вершины нумеруются с 0.

## Выходные данные
YES, если данный граф содержит эйлеров цикл, и NO в противном случае.

## Примеры
Вход|Выход
---|---
6<br>0 2 0 0 1 0<br>2 0 1 0 1 0<br>0 1 0 1 0 0<br>0 0 1 0 1 1<br>1 1 0 1 0 0<br>0 0 0 1 0 0|NO
6<br>0 1 0 0 1 0<br>1 0 1 0 1 1<br>0 1 0 1 0 0<br>0 0 1 1 0 1<br>1 1 0 0 1 0<br>0 1 0 1 0 0|YES

## [Решение](eulerian.c)

---

# dijkstra

## Алгоритм Дейкстры
Неориентированный взвешенный граф без петель задан списком рёбер, для каждого ребра указана его длина. Найдите кратчайшие расстояния от данной вершины графа до всех остальных.

## Входные данные
На первой строке задаётся число N (1 ≤ N ≤ 100) – количество вершин в графе, и M (1 ≤ M ≤ N(N - 1)/2) - количество рёбер. Затем следует M строк, в каждой из которых через пробел указывается 3 неотрицательных числа - номера двух соединённых вершин графа и длина ребра (в указанном порядке). На последней строчке указывается номер исходной вершины, от которой надо искать кратчайшие расстояния до всех остальных. Считаем, что вершины нумеруются с 0.

## Выходные данные
Строка, в которой через пробел выводится N чисел - кратчайшие расстояния до соответствующих вершин, в порядке увеличения номера вершины.

## Примеры
Вход|Выход
---|---
6 9<br>0 1 7<br>1 3 15<br>3 4 6<br>4 5 9<br>5 0 14<br>0 2 9<br>1 2 10<br>3 2 11<br>5 2 2<br>0|0 7 9 20 20 11
5 8<br>0 1 10<br>0 2 30<br>0 3 50<br>0 4 10<br>1 3 40<br>2 3 20<br>2 4 10<br>3 4 30<br>0|0 10 20 40 10

## [Решение](dijkstra.cpp)

---

# mintree - Минимальное остовное дерево

## Алгоритм Прима
Неориентированный взвешенный связный пока что граф с петлями задан списком рёбер, для каждого ребра указана его длина. Веса всех ребер неотрицательны. Найдите минимальное покрывающее дерево.

## Входные данные
На первой строке задаётся число N (1 < N < 1024) – количество вершин в графе, и M (1 < M < N(N - 1)/2) - количество рёбер. Затем следует M строк, в каждой из которых через пробел указывается 3 неотрицательных числа - номера двух соединённых вершин графа и длина ребра (в указанном порядке). Считать, что данные корректны. Длина каждого ребра не превосходит 0x100.

## Выходные данные
Cумма длин ребер дерева.

## Примеры
Вход|Выход
---|---
5 5<br>0 1 5<br>0 2 10<br>1 3 4<br>1 4 10<br>2 4 6|25

## [Решение](mintree.cpp)

---

# border

## Визит за границу
Пете необходимо из пункта A попасть в пункт B. Но он хочет использовать случай и заодно заехать в дружественую страну, граница с которой пролегает совсем поблизости.
При этом он хочет, чтобы его путь был как можно короче, покольку времени не так уж и много.

Помогите ему решить эту задачу.

Поезда курсируют между всеми городами.

## Входные данные
В первой строчке заданы количество городов N (3 ≤ N ≤ 300). Затем идет действительное число R. Затем идут N строчек с описанием их кординат. В каждой строчке координаты X и Y, разделенные пробелом. Граница с дружественной страной — прямая x = 0. Города A и B — это первые два города. Координата X городов A и B положительна. Один из указанных городов лежит за границей, то есть имеет X < 0. Все координаты — действительные числа по модулю меньше 100000.

Известно, что по крайней мере один путь, удовлетворяющий условиям, существует.

Дороги проведены только между теми городами, между которыми расстояние меньше либо равно R.

## Выходные данные
Минимальная длина пути. (отличие от правильного ответа не должно превосходить 0.01).

P.S. Заметьте, что в принципе Петя может заехать в B, потом за границу, а потом опять в B. Но расположение городов такое, что этого не бывает.

## Примеры
Вход|Выход
---|---
4<br>4.5<br>1 -1<br>1 1<br>-1 -1<br>-1 1|4.828

## [Решение](border.cpp)

---

# loop

## Поиск цикла
Дан ориентированный невзвешенный граф без петель и кратных рёбер. Необходимо определить есть ли в нём циклы, и если есть, то вывести любой из них.

## Входные данные
В первой строке входного файла находятся два натуральных числа N и M (1 ≤ N ≤ 100000, M⩽100000) — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.

## Выходные данные
Если в графе нет цикла, то вывести «NO», иначе — «YES» и затем перечислить все вершины в порядке обхода цикла.

## Примеры
Вход|Выход
---|---
2 2<br>1 2<br>2 1|YES<br>1 2
3 3<br>1 2<br>2 3<br>1 3|NO

## [Решение](loop.cpp)

---

# condense

## -||-
Требуется найти количество ребер в конденсации ориентированного графа. Примечание: конденсация графа не содержит кратных ребер.

## Входные данные
Первая строка входного файла содержит два натуральных числа n и m — количество вершин и рёбер графа соответственно (n≤10000, m≤100000). Следующие m строк содержат описание ребер, по одному на строке. Ребро номер i описывается двумя натуральными числами bi,ei — началом и концом ребра соответственно (1≤bi, ei≤n).

В графе могут присутствовать кратные ребра и петли.

## Выходные данные
Первая строка выходного файла должна содержать одно число — количество ребер в конденсации графа.

## Примеры
Вход|Выход
---|---
4 4<br>2 1<br>3 2<br>2 3<br>4 3|2

## [Решение](condense.cpp)

---

# top

## Топологическая сортировка
В Ямальском Химико-Техническом институте из 5ТОП100 обновляют учебный план. Для этого составили ориентированный граф зависимостей предметов, например, "для изучения дифференциальных уравнений требуется предварительно знать математический анализ". Но вот в каком порядке излагать эти предметы, чтобы зависимости не нарушались?

Дан ориентированный невзвешенный граф предметов. Необходимо его топологически отсортировать, чтобы предметы, которые нужно преподать в качестве пререквизитов, были раньше зависимостей.

## Входные данные
В первой строке входного файла даны два натуральных числа N и M (1 ≤ N ≤ 100000, M ≤ 100000) — количество вершин и рёбер в графе соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин соответственно.

## Выходные данные
Вывести любую топологическую сортировку графа в виде последовательности номеров вершин. Если граф невозможно топологически отсортировать, вывести -1.

## Примеры
Вход|Выход
---|---
6 6<br>1 2<br>3 2<br>4 2<br>2 5<br>6 5<br>4 6|4 6 3 1 2 5

## [Решение](top.cpp)

---
